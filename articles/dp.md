# 关于动态规划自己的总结

动态规划的基本套路
1. 初始化数组，这个有时候是初始化全为0，也有的全为1
2. 找到最小阶的计算规则，也就是状态转移方程
3. 获取最后的条件

动态规划的过程
1. 比如最经典的就是[爬楼梯](../solutions/70-爬楼梯.md)，这个就是获取最后一个结果就是
2. 再深一点就是[最长回文子序列](../solutions/516-最长回文子序列.md)，这里虽然也是获取最后一个结果，但是这里是二维数组，而且最后一位的设置方式还不一样，是 dp[0][n-1] 第一个和第二个的位置是不一样的
[零钱兑换](../solutions/322-零钱兑换.md) 这种则需要设置最初始的数组中值，最后需要与数组中的值进行一次比较
3. 能直接计算当前这一步的，如 `dp[i] = dp[i - 1] + 1`，类似斐波那契数列这种，最长公共子串的计算，如果不能直接这样计算，需要判断条件的，如当前这一步不符合，
那么就需要考虑前一步结果来进行比较，如 `dp[i][j] = Math.max(dp[i - 1][j], dp[i][j-1])` 这种的，如
   - [516-最长回文子序列](../solutions/516-最长回文子序列.md)
   - [1143-最长公共子序列](../solutions/1143-最长公共子序列.md)
   - [最长公共子串](../solutions/最长公共子串.md)
    
一般如果是求子序列，那么这时候中间某个条件不符合，那么就可以使用 `dp[i][j] = Math.max(dp[i - 1][j], dp[i][j-1])`
而如果是求子串，这时候如果某个条件不符合，就只能重新开始了，所以在最长公共子串的求解中，不符合的时候就需要直接 `dp[i][j]`直接置为0 了，也就是重置为初始条件了     

动态规划的优化
1. 因为动态规划是需要遍历很多层的，比如 dp[i] 会依赖于 dp[i - 1] 这种的，所以一般需要使用备忘录，也就是建立一个缓存来保存计算过的 dp[i] 的值，这样后续就不用重新计算了，比如[509-斐波那契数列](../solutions/509-斐波那契.md)就是这样，专业的术语叫用备忘录消除重叠子问题
2. 然后从斐波那契数列数列中可以看到，建立dp也是需要空间复杂度的，这时候看每次dp[i]的计算是否只依赖于前一次或者前两次，这样其实就可以用一个变量来代替 dp了，这样空间复杂度也可以减少了 
