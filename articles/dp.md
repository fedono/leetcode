# 关于动态规划自己的总结

动态规划也是有套路的
1. 初始化数组
2. 找到最小阶的计算规则
3. 获取最后的条件

比如最经典的就是[爬楼梯](../solutions/70-爬楼梯.md)，这个就是获取最后一个结果就是
再深一点就是[最长回文子序列](../solutions/516-最长回文子序列.md)，这里虽然也是获取最后一个结果，但是这里是二维数组，而且最后一位的设置方式还不一样，是 dp[0][n-1] 第一个和第二个的位置是不一样的
[零钱兑换](../solutions/322-零钱兑换.md) 这种则需要设置最初始的数组中值，最后需要与数组中的值进行一次比较

动态规划的优化
1. 因为动态规划是需要遍历很多层的，比如 dp[i] 会依赖于 dp[i - 1] 这种的，所以一般需要使用备忘录，也就是建立一个缓存来保存计算过的 dp[i] 的值，这样后续就不用重新计算了，比如[509-斐波那契数列](../solutions/509-斐波那契.md)就是这样，专业的术语叫用备忘录消除重叠子问题
2. 然后从斐波那契数列数列中可以看到，建立dp也是需要空间复杂度的，这时候看每次dp[i]的计算是否只依赖于前一次或者前两次，这样其实就可以用一个变量来代替 dp了，这样空间复杂度也可以减少了 
