# 5-最长回文字符串

> 第516-最长回文子序列是计算最长回文的长度，这里是将回文返回


首先来一个最好理解的，
时间复杂度是 O(n^3)
空间复杂度是 O(1)
```javascript
const longestPalindrome = function (s) {
    let ans = '';
    let max = 0;
    let len = s.length;
    for (let i = 0; i < len; i++) {
        for (let j = i + 1; j < len; j++) {
            let tempStr = s.substring(i, j);
            // 每次判断当前是否是回文字符串，然后判断长度是否大于 max
            if (isPalindrome(tempStr) && tempStr.length > max) {
                ans = s.substring(i, j);
                max = tempStr.length;
            }
        }
    }

    return ans;
}

function isPalindrome(str) {
    let len = str.length;
    let middle = parseInt(len / 2);
    // 不管是奇数还是偶数，都可以通过这种方式
    // 奇数 caac 比较的是 0->3 1->2
    // 偶数 cac 比较的是 0->2 中间的 1 是不用比较的
    for (let i = 0; i < middle; i++) {
        // 这个是比较回文字符串比好好的方式
        if (str[i] !== str[len - i - 1]) {
            return false;
        }
    }

    return true;
}

let result = longestPalindrome('abbcaacz');
console.log(result);
```

第二种方式是使用动态规划的方式
时间复杂度 O(n^2)
空间复杂度 O(n) -> 二位数组的空间复杂度应该也是 O(n) 吧？
```javascript
const longestPalindrome = function (s) {
    let n = s.length;
    let res = '';
    let dp = Array.from(new Array(n), () => new Array(n).fill(0));

    // 这个解法感觉不太好记啊
    for (let i = n - 1; i >= 0; i--) {
        for (let j = i + 1; j < n; j++) {
            // 设置当前 dp[i][j] 是否是回文字符串
            dp[i][j] = (
                // s[i] === s[j] 说明当前是字符串
                s[i] === s[j]
                // j - i < 2 是 j = i + 1 的情况，这时候因为 dp[i + 1][j - 1] 是 undefined，没有值，
                // 所以这时候如果 s[i] === s[j] 就直接返回 true 就可以
                // dp[i + 1][j - 1] 说明之前也是一个回文字符串
                && (j - i < 2 || dp[i + 1][j - 1])
            );

            // 如果当前是一个回文字符串，并且长度比之前计算的回文字符串长，那么就继续更新最长回文字符串的长度
            if (dp[i][j] && (j - i + 1 > res.length)) {
                res = s.substring(i, j + 1);
            }
        }
    }

    return res;
}

let result = longestPalindrome('abbcaac');
console.log(result);
```