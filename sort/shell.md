# 希尔排序

希尔排序是基于插入排序的以下两点性质而提出改进方法的：
- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
- 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

Donald Shell最初建议步长选择2/n并且对步长取半直到步长达到1。虽然这样取可以比O(n2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。

## 解法
```javascript
const shellSort = function(arr, len) {
    for (let gap = len >> 1; gap > 0; gap >>= 1) {
        for (let i = gap; i < len; i++) {
            let temp = arr[i];
            let j;
            for (j = i - gap; j >= 0 && arr[j] > temp; j -= gap) {
                arr[j + gap] = arr[j];
            }
            arr[j + gap] = temp;
        }
    }
    return arr;
}

let arr = [ 13, 14, 94, 33, 82, 25, 59, 94, 65, 23, 45, 27, 73, 25, 39, 10 ];
let res = shellSort(arr, arr.length);
console.log(res);
```

## 算法实现

希尔排序通过将比较的全部元素分为几个区域来提升[插入排序](https://zh.wikipedia.org/wiki/插入排序)的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的[插入排序](https://zh.wikipedia.org/wiki/插入排序)，但是到了这步，需排序的数据几乎是已排好的了（此时[插入排序](https://zh.wikipedia.org/wiki/插入排序)较快）。

假设有一个很小的数据在一个已按升序排好序的[数组](https://zh.wikipedia.org/wiki/數組)的末端。如果用复杂度为O(*n*2)的排序（[冒泡排序](https://zh.wikipedia.org/wiki/冒泡排序)或[插入排序](https://zh.wikipedia.org/wiki/插入排序)），可能会进行*n*次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。

一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用[插入排序](https://zh.wikipedia.org/wiki/插入排序)）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用`i += step_size`而不是`i++ `）。

例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：

```
13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
```

然后我们对每列进行排序：

```
10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45
```

将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：

```
10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
```

排序之后变为：

```
10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
```

最后以1步长进行排序（此时就是简单的插入排序了）。