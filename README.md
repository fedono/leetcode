# 总结

[如何判断程序的复杂度](./complexity.md)
[参考](./reference.md)

> 按照类别分类来刷
> 刷当前题的时候，看下『题目描述』最底下有个『相似题目』，这些题的思路大致也相当
> 通常都是看别人的面经，然后看到有LeetCode题，然后来刷，比如有些DP的题，看完当前的题的时候，可以把当前DP类的简单的都刷下，毕竟简单的一般都不用怎么思考，就是学习一下思路

## 排序
- [排序](./sort/README.md)

## 字符串
[14-最长公共前缀](./solutions/14-最长公共前缀.md)\
[22-括号生成](./solutions/22-括号生成.md)\
[43-字符串相乘](./solutions/43-字符串相乘.md)\
[76-最小覆盖子串](./solutions/76-最小覆盖子串.md)\
[151-翻转字符串里的单词](./solutions/151-翻转字符串里的单词.md)\
[242-有效的字母异位词](./solutions/242-有效的字母异位词.md)\
[344-反转字符串](./solutions/344-反转字符串.md)\
[394-字符串解码](./solutions/394-字符串解码.md)\
[438-找到字符串中所有字母异位词](./solutions/438-找到字符串中所有字母异位词.md)\
[844-比较含退格的字符串](./solutions/844-比较含退格的字符串.md)\
[1663-具有给定数值的最小字符串](./solutions/1663-具有给定数值的最小字符串.md)\
[字符串匹配]
> 搜索一下 阮一峰 kmp (阮老师有一篇讲 kmp 的还挺好的)

[大数相加](./solutions/大数相加.md)\

## 数组
> [总结](./articles/array.md)
[1-两数之和](./solutions/1-两数之和.md)\
[11-盛最多水的容器](./solutions/11-盛最多水的容器.md)\
[15-三数之和](./solutions/15-三数之和.md)\
[26-删除有序数组中的重复项](./solutions/26-删除有序数组中的重复项.md)\
[42-接雨水](./solutions/42-接雨水.md)\
[49-字母异位词分组](./solutions/49-字母异位词分组.md)\
[53-最大子序和](./solutions/53-最大子序和.md)\
[56-合并区间](./solutions/56-合并区间.md)\
[80-删除有序数组中的重复项-ii](./solutions/80-删除有序数组中的重复项-ii.md)\
[283-移动零](./solutions/283-移动零.md)\
[349-两个数组的交集](./solutions/349-两个数组的交集.md)\
[350-两个数组的交集2](./solutions/350-两个数组的交集2.md)\
[384-打乱数组](./solutions/384-打乱数组.md)\
[509-斐波那契](./solutions/509-斐波那契.md)\
[560-和为K的子数组](./solutions/560-和为K的子数组.md)\
[692-前K个高频单词](./solutions/692-前K个高频单词.md)\
[697-数组的度](./solutions/697-数组的度.md)\
[969-烧饼排序](./solutions/969-烧饼排序.md)\
[1002-查找常用字符](./solutions/1002-查找常用字符.md)\
[215-数组中的第K个最大元素](./solutions/215-数组中的第K个最大元素.md)\
[1296-划分数组为连续的数字的集合](./solutions/1296-划分数组为连续的数字的集合.md)\
[17-电话号码的字母组合 | 也叫多维数组合并成单维数组](./solutions/17-电话号码的字母组合.md)\
[一个已排序好的数组，找到匹配num的index，需要最优解（使用二分法，但是如何写这个二分法）](./solutions/-找到匹配值.md)\
[连续出现的数字区间](./solutions/连续出现的数字区间.md)\
[阿拉伯数字转中文](./solutions/阿拉伯数字转中文.md)\
[去除数组重复项-数组中含有对象](./solutions/去除数组重复项.md)


## 栈和队列
> 队列是先进先出，栈是先进后出
[20-有效的括号](./solutions/20-有效的括号.md)\ 
[有效的括号-ii](./solutions/有效的括号-ii.md)\
[239-滑动窗口最大值](./solutions/239-滑动窗口最大值.md)\
- valid-parentheses
- 155 min-stack
- design-circular-deque
- trapping-rain-water

## 滑动窗口
> 通过窗口的大小不断调整来找到合适的值，或者窗口大小不变，通过左右移动来找到相应的结果
[3-无重复字符的最长子串](./solutions/3-无重复字符的最长子串.md)\
[76-最小覆盖子串](./solutions/76-最小覆盖子串.md)\
[438-找到字符串中所有字母异位词](./solutions/438-找到字符串中所有字母异位词.md)\

### 其他
> 非 LeetCode 题，单纯在别人面试中看到的
[组成顺子的概率](./solutions/组成顺子的概率.md)\
[剑指Offer61-扑克牌中的顺子](./solutions/剑指Offer61-扑克牌中的顺子.md)\

## 链表
[206-反转链表](./solutions/206-翻转链表.md)\
[106-相交链表](./solutions/106-相交链表.md)\
[61-旋转链表](./solutions/61-旋转链表.md)\
[146-LRU缓存机制](./solutions/146-LRU缓存机制.md)\
[876-链表的中间节点](./solutions/876-链表的中间节点.md)\
- swap-nodes-in-pairs
- linked-list-cycle
- linked-list-cycle-ii
- reverse-nodes-in-k-group

## 二叉树
- [ ] 实现一个二叉树
- [ ] 二叉树二叉树的前中后序遍历\
[94-二叉树的中序遍历](./solutions/94-二叉树的中序遍历.md)\
[144-二叉树的前序遍历](./solutions/144-二叉树的前序遍历.md)\
[145-二叉树的后序遍历](./solutions/145-二叉树的后序遍历.md)\
[958-二叉树的完全性检验](./solutions/958-二叉树的完全性检验.md)\
[105-已知前中序，求原有的二叉树](./solutions/105-已知前中序，求原有的二叉树.md)\
[173-二叉搜索树迭代器](./solutions/173-二叉搜索树迭代器.md)\
  > 这题还是没太理解解法的含义
[823-带因子的二叉树](./solutions/823-带因子的二叉树.md)\
- binary-tree-inorder-traversal
- binary-tree-preorder-traversal
- n-ary-tree-postorder-traversal
- n-ary-tree-level-order-traversal 
- invert-binary-tree
- validate-binary-search-tree
- maximum-depth-of-binary-tree
- minimum-depth-of-binary-tree
- serialize-and-deserialize-binary-tree
- lowest-common-ancestor-of-a-binary-tree
- construct-binary-tree-from-preorder-and-inorder-traversal
- combinations
- permutations
- permutations-ii
  
## 深度/广度
- [深度/广度遍历](./solutions/深度-广度遍历.md)
- [491-递增子序列](./solutions/491-递增子序列.md)

## 动态规划
[5-最长回文字符串](./solutions/5-最长回文字符串.md)\
[10-正则表达式匹配](./solutions/10-正则表达式匹配.md)\
[42-接雨水](./solutions/42-接雨水.md)\
[62-不同路径](./solutions/62-不同路径.md)\
[63-不同路径2](./solutions/63-不同路径2.md)\
[70-爬楼梯](./solutions/70-爬楼梯.md)\
[70-青蛙跳台阶问题](./solutions/70-青蛙跳台阶问题.md)\
[72-编辑距离](./solutions/72-编辑距离.md)
> 这个的解法和651-四键键盘的解法还是挺像的，每次都是有不同路径，然后每次都是遍历每一次的路径，然后看最优的那一个作为当前的这个
> 
[115-不同的子序列](./solutions/115-不同的子序列.md)\
[300-最长递增子序列](./solutions/300-最长递增子序列.md)\
[322-零钱兑换](./solutions/322-零钱兑换.md)\
[416-分割等和子集](./solutions/416-分割等和子集.md)\
[516-最长回文子序列](./solutions/516-最长回文子序列.md)\
[651-四键键盘](./solutions/651-四键键盘.md)\
[887-鸡蛋掉落](./solutions/887-鸡蛋掉落.md)\
[1143-最长公共子序列](./solutions/1143-最长公共子序列.md)\
[背包问题](./solutions/背包问题.md)

## 贪心算法
> 每次都选择当前这一步的最优的选择，以达到全局的最优

[区间调度](./solutions/区间调度.md)\
[55-跳跃游戏](./solutions/55-跳跃游戏.md)\
[121-买卖股票的最佳时机](./solutions/121-买卖股票的最佳时机.md)
[122-买卖股票的最佳时机-ii](./solutions/122-买卖股票的最佳时机-ii.md)
[435-无重叠区间](./solutions/435-无重叠区间.md)\
[455-分发饼干](./solutions/455-分发饼干.md)\
[860-柠檬水找零](./solutions/860-柠檬水找零.md)\
[1663-具有给定数值的最小字符串](./solutions/1663-具有给定数值的最小字符串.md)\
- walking-robot-simulation
- jump-game
- jump-game-ii

## 双指针

[986-区间列表的交集](./solutions/986-区间列表的交集.md)\
[11]
[42]
[283]
[80]
[1047]

## 回溯法
> 回溯主要还是要考 DFS，然后就是把在递归前的数据设置一下，递归之后设置回来，然后第三点就是在判断条件符合输出条件的时候，添加到结果集中，并return空。
> 
> 所以要考虑的点就是，在设置进入递归的条件是什么？

[22-括号生成](./solutions/22-括号生成.md)\
[32-最长有效括号](./solutions/32-最长有效括号.md)\
[39-组合总和](./solutions/39-组合总和.md)\
[46-全排列](./solutions/46-全排列.md)\
[47-全排列-ii](./solutions/47-全排列-ii.md)\
[51-N皇后](./solutions/51-N皇后.md)\
[78-子集](./solutions/78-子集.md)\
[90]
[]
- majority-element
- letter-combinations-of-a-phone-number

## 二分查找
> 二分法求解的时候是需要注意左右边界的，参考[二分查找详解](https://labuladong.gitee.io/algo/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3/#_4)

[354-俄罗斯套娃信封问题](./solutions/354-俄罗斯套娃信封问题.md)\
[875-爱吃香蕉的珂珂](./solutions/875-爱吃香蕉的珂珂.md)\
[1011-在D天内送达包裹的能力](./solutions/1011-在D天内送达包裹的能力.md)\

## 暂未归类
[611-有效三角形的个数](./solutions/611-有效三角形的个数.md)\
[836-矩形重叠](./solutions/836-矩形重叠.md)\
[223-矩形面积](./solutions/223-矩形面积.md)\
[寻找素数](./solutions/寻找素数.md)


## 算法经典解法集合
>  leetcode 题解法
- Dijkstra/迪杰斯特拉（计算最短路径
    > Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。 主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。
- 贪心算法
    > 是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。
- 动态规划
- 回溯
    > 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。
- 分治
    > 在计算机科学中，分治法是构建基于多项分支递归的一种很重要的算法范式。字面上的解释是「分而治之」，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。
    这个技巧是很多高效算法的基础，如排序算法（快速排序、归并排序）、傅立叶变换（快速傅立叶变换）。
- 指针
